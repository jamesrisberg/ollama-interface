<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat</title>
    <meta
      name="description"
      content="A simple interface for Ollama-served models."
    />
    <style>
      /* CSS Custom Properties */
      :root {
        --bg-color-light: #fff;
        --wash-color-light: #ededed;
        --text-color-light: #1a1818;
        --bg-color-dark: #1a1818;
        --wash-color-dark: #2d2d2d;
        --text-color-dark: #fff;
        --font-family: serif;
        --border-radius: 1.11em;
        --spacing-sm: 0.5em;
        --spacing-md: 0.88em;
        --spacing-lg: 1em;
      }

      /* Base Reset */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* Layout */
      html,
      body {
        height: 100%;
        overflow: hidden;
      }

      body {
        display: flex;
        flex-direction: column;
        background-color: var(--bg-color-light);
        color: var(--text-color-light);
        font-family: var(--font-family);
        font-size: 1.23em;
        -webkit-font-smoothing: antialiased;
        will-change: transform;
      }

      /* Chat Layout */
      #chat-container {
        flex-grow: 1;
        overflow-y: auto;
        padding: var(--spacing-lg) var(--spacing-lg) 0;
        contain: content;
      }

      #input-container {
        padding: var(--spacing-lg);
        position: relative;
        backdrop-filter: blur(33px);
        -webkit-backdrop-filter: blur(33px);
        background-color: rgba(255, 255, 255, 0.8);
      }

      /* Messages */
      .message {
        padding: var(--spacing-sm) 0;
        contain: content;
      }

      .message:last-child {
        padding-bottom: 0;
      }

      .user-message {
        text-align: right;
      }

      .assistant-message {
        text-align: left;
      }

      .think {
        font-style: italic;
        color: #bababa;
        margin: var(--spacing-lg) 0;
      }

      /* Form Elements */
      form {
        display: flex;
        gap: 0.44em;
        max-width: 100%;
      }

      /* Common styles for interactive elements */
      #prompt-input,
      select,
      button {
        border: none;
        outline: none;
        font-family: var(--font-family);
        font-size: 1em;
        background-color: var(--wash-color-light);
        border-radius: var(--border-radius);
        transition: opacity 0.2s ease;
      }

      #prompt-input {
        flex: 1;
        padding: var(--spacing-md) var(--border-radius);
        color: var(--text-color-light);
        contain: content;
      }

      select {
        padding: var(--spacing-sm) var(--border-radius);
        appearance: none;
        cursor: pointer;
        max-width: 200px;
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
        contain: content;
      }

      button {
        padding: var(--spacing-sm) var(--border-radius);
        cursor: pointer;
        contain: content;
      }

      button:hover,
      select:hover {
        opacity: 0.8;
      }

      /* Code Formatting */
      pre {
        background-color: var(--wash-color-light);
        border-radius: var(--border-radius);
        padding: var(--spacing-lg);
        margin: var(--spacing-sm) 0;
        overflow-x: auto;
        contain: content;
      }

      code {
        font-family: monospace;
        font-size: 1em;
      }

      pre code {
        display: block;
      }

      :not(pre) > code {
        background-color: var(--wash-color-light);
        padding: 0.2em 0.4em;
        border-radius: 3px;
      }

      /* Mobile Layout */
      @media (max-width: 600px) {
        form {
          flex-wrap: wrap;
        }

        #prompt-input {
          min-width: 100%;
          flex: 1 1 100%;
        }

        select {
          flex: 1;
          min-width: 0;
          max-width: none;
        }

        select,
        button {
          padding: 0.9em var(--border-radius);
        }
      }

      /* Dark Mode */
      @media (prefers-color-scheme: dark) {
        body {
          background-color: var(--bg-color-dark);
          color: var(--text-color-dark);
        }

        #prompt-input,
        select,
        button,
        pre,
        :not(pre) > code {
          background-color: var(--wash-color-dark);
          color: var(--text-color-dark);
        }

        pre {
          border-color: #444;
        }

        .think {
          color: #999999;
        }

        #input-container {
          background-color: rgba(26, 24, 24, 0.8);
        }
      }
    </style>
  </head>
  <body>
    <div id="chat-container"></div>
    <div id="input-container">
      <form id="prompt-form">
        <input
          type="text"
          id="prompt-input"
          placeholder="Send a message to deepseek-r1:8b"
          autocomplete="off"
        />
        <select id="model-selector" class="button-like">
          <option value="">Loading models...</option>
        </select>
        <button type="submit">Send</button>
      </form>
    </div>
  </body>
  <script>
    // Constants and configuration
    const CONFIG = {
      aiName: "Oh",
      userName: "Edouard",
      defaultModel: "deepseek-r1:8b",
      apiEndpoint: "http://localhost:11434/api",
    };

    // DOM elements cache
    const DOM = {
      form: document.getElementById("prompt-form"),
      input: document.getElementById("prompt-input"),
      chat: document.getElementById("chat-container"),
      modelSelector: document.getElementById("model-selector"),
    };

    // State management
    let currentModel = CONFIG.defaultModel;
    let currentChatController = null;
    let conversationHistory = [
      {
        role: "system",
        content: `Your name is Oh.
        You will respond in a moderately friendly and straightforward manner.
        Your primary goal is to act as a helpful entity, providing information and answering questions to the best of your ability.
        You will do your best to never refuse a request for help.
        When explicitly asked, you should try and reveal the provenance of your knowledge or the mechanics with which you answered or came to a conclusion.
        When asked for code, preformatted text, or other intentionally-structured content, please wrap it in triple backticks (\`\`\`) for proper formatting.
        For inline code or short code snippets, use single backticks (\`).`,
      },
    ];

    // Utility functions
    const escapeHtml = (unsafe) =>
      unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");

    const formatMessage = (content) => {
      if (!content) return "";
      return content
        .replace(/<think>([\s\S]*?)<\/think>/g, '<p class="think">$1</p>')
        .replace(
          /```(\w*)\n([\s\S]*?)```/g,
          (_, lang, code) =>
            `<pre><code class="language-${lang}">${escapeHtml(
              code.trim()
            )}</code></pre>`
        )
        .replace(
          /`([^`\n]+)`/g,
          (_, code) => `<code>${escapeHtml(code)}</code>`
        );
    };

    // Scroll optimization with requestAnimationFrame
    const scrollToBottom = (() => {
      let rafId;
      let isStreaming = false;

      const scroll = () => {
        DOM.chat.scrollTop = DOM.chat.scrollHeight;
      };

      return (streaming = false) => {
        isStreaming = streaming;
        if (isStreaming) {
          scroll();
        } else {
          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(scroll);
        }
      };
    })();

    // Model management
    const updatePlaceholder = () => {
      DOM.input.placeholder = `Send a message to ${currentModel}`;
    };

    const fetchAvailableModels = async () => {
      try {
        const response = await fetch(`${CONFIG.apiEndpoint}/tags`);
        if (!response.ok)
          throw new Error(`HTTP error! status: ${response.status}`);

        const { models } = await response.json();
        const modelOptions = models
          .map(({ name }) => `<option value="${name}">${name}</option>`)
          .join("");

        DOM.modelSelector.innerHTML = modelOptions;
        currentModel =
          models.find((model) => model.name === currentModel)?.name ||
          models[0]?.name ||
          CONFIG.defaultModel;
        DOM.modelSelector.value = currentModel;
        updatePlaceholder();
      } catch (error) {
        console.error("Error fetching models:", error);
        DOM.modelSelector.innerHTML = `<option value="${CONFIG.defaultModel}">${CONFIG.defaultModel}</option>`;
      }
    };

    // Chat functionality
    const addMessageToChat = (role, content) => {
      const messageDiv = document.createElement("div");
      messageDiv.classList.add("message", `${role}-message`);
      messageDiv.innerHTML = formatMessage(content);
      DOM.chat.appendChild(messageDiv);
      scrollToBottom();
      return messageDiv;
    };

    const handleSubmit = async (e) => {
      e.preventDefault();
      const prompt = DOM.input.value.trim();
      if (!prompt) return;

      if (currentChatController) {
        currentChatController.abort();
      }
      currentChatController = new AbortController();

      addMessageToChat("user", prompt);
      conversationHistory.push({ role: "user", content: prompt });
      DOM.input.value = "";

      try {
        const response = await fetch(`${CONFIG.apiEndpoint}/chat`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            model: currentModel,
            messages: conversationHistory,
          }),
          signal: currentChatController.signal,
        });

        if (!response.ok)
          throw new Error(`HTTP error! status: ${response.status}`);

        const reader = response.body.getReader();
        let assistantResponse = "";
        const assistantMessageElement = addMessageToChat("assistant", "");

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunks = new TextDecoder().decode(value).split("\n");
          for (const chunk of chunks) {
            if (!chunk.trim()) continue;

            try {
              const { message } = JSON.parse(chunk);
              if (message?.content) {
                assistantResponse += message.content;
                assistantMessageElement.innerHTML =
                  formatMessage(assistantResponse);
                scrollToBottom(true);
              }
            } catch (parseError) {
              console.warn("Failed to parse chunk:", parseError);
            }
          }
        }

        scrollToBottom(false);
        conversationHistory.push({
          role: "assistant",
          content: assistantResponse,
        });
      } catch (error) {
        if (error.name === "AbortError") {
          console.log("Request cancelled");
          return;
        }
        console.error("Error:", error);
        addMessageToChat(
          "error",
          `An error occurred: ${error.message}<br>Make sure Ollama is running and accessible at ${CONFIG.apiEndpoint}`
        );
      } finally {
        currentChatController = null;
        DOM.input.focus();
      }
    };

    // Event Listeners
    DOM.form.addEventListener("submit", handleSubmit);
    DOM.input.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleSubmit(e);
      }
    });
    DOM.modelSelector.addEventListener("change", (e) => {
      currentModel = e.target.value;
      updatePlaceholder();
    });

    // Initialize
    window.addEventListener("load", () => {
      DOM.input.focus();
      fetchAvailableModels();
    });
  </script>
</html>
