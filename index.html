<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat</title>
    <meta
      name="description"
      content="A simple interface for Ollama-served models."
    />
    <style>
      /* CSS Custom Properties */

      /* Font settings */
      @font-face {
        font-family: 'JetBrains Mono';
        src: url('https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2')
          format('woff2');
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      :root {
        --bg-color-light: #fff;
        --wash-color-light: #ededed;
        --text-color-light: #1a1818;
        --bg-color-dark: #1a1818;
        --wash-color-dark: #2d2d2d;
        --text-color-dark: #fff;
        --font-family: 'JetBrains Mono', monospace;
        --border-radius: 1.11em;
        --spacing-sm: 0.5em;
        --spacing-md: 0.88em;
        --spacing-lg: 1em;
      }

      /* Base Reset */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* Layout */
      html,
      body {
        height: 100%;
        overflow: hidden;
      }

      body {
        display: flex;
        flex-direction: column;
        background-color: var(--bg-color-light);
        color: var(--text-color-light);
        font-family: var(--font-family);
        font-size: 1em;
        -webkit-font-smoothing: antialiased;
        will-change: transform;
      }

      /* Chat Layout */
      #chat-container {
        flex-grow: 1;
        overflow-y: auto;
        padding: var(--spacing-lg) var(--spacing-lg) 0;
        contain: content;
      }

      #input-container {
        padding: var(--spacing-lg);
        position: relative;
        backdrop-filter: blur(33px);
        -webkit-backdrop-filter: blur(33px);
        background-color: rgba(255, 255, 255, 0.8);
      }

      /* Messages */
      .message {
        padding: var(--spacing-sm) 0;
        contain: content;
        position: relative;
      }

      .message-content {
        position: relative;
        display: inline-block;
        max-width: 100%;
      }

      .message:last-child {
        padding-bottom: 0;
      }

      .user-message {
        padding-left: 20%;
        text-align: right;
      }

      .assistant-message {
        padding-right: 20%;
        text-align: left;
      }

      .think {
        font-style: italic;
        color: #bababa;
        margin: var(--spacing-lg) 0;
        position: relative;
        padding-left: 1.5em;
        overflow: hidden;
        transition: max-height 0.2s ease-out;
        max-height: none;
      }

      .think.collapsed {
        max-height: 1.5em;
        cursor: pointer;
      }

      .think.collapsing {
        transition: max-height 0.2s ease-out;
      }

      .think::before {
        content: '▼';
        position: absolute;
        left: 0;
        top: 0.2em;
        font-size: 0.8em;
        transition: transform 0.2s ease;
        cursor: pointer;
        line-height: 1;
        display: inline-block;
        width: 1em;
        height: 1em;
        text-align: center;
      }

      .think.collapsed::before {
        transform: rotate(-90deg);
      }

      .think.collapsed::after {
        content: '...';
        color: #bababa;
      }

      /* Form Elements */
      form {
        display: flex;
        gap: 0.44em;
        max-width: 100%;
        align-items: flex-end;
      }

      /* Common styles for interactive elements */
      #prompt-input,
      select,
      button {
        border: none;
        outline: none;
        font-family: var(--font-family);
        font-size: 1em;
        background-color: var(--wash-color-light);
        border-radius: var(--border-radius);
        transition: opacity 0.2s ease;
      }

      #prompt-input {
        flex: 1;
        padding: var(--spacing-md) var(--border-radius);
        color: var(--text-color-light);
        contain: content;
        resize: none;
        overflow-y: auto;
        line-height: 1.2em;
        max-height: calc(1.2em * 5 + var(--spacing-md) * 2);
      }

      select {
        padding: var(--spacing-md) var(--border-radius);
        appearance: none;
        cursor: pointer;
        max-width: 333px;
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
        contain: content;
        align-self: flex-end;
      }

      button {
        padding: var(--spacing-md) var(--border-radius);
        cursor: pointer;
        contain: content;
        align-self: flex-end;
      }

      button:hover,
      select:hover {
        opacity: 0.8;
      }

      /* Code Formatting */
      pre {
        background-color: var(--wash-color-light);
        border-radius: var(--border-radius);
        padding: var(--spacing-lg);
        margin: var(--spacing-sm) 0;
        overflow-x: auto;
        contain: content;
      }

      code {
        font-family: monospace;
        font-size: 0.9em;
      }

      pre code {
        display: block;
      }

      :not(pre) > code {
        background-color: var(--wash-color-light);
        padding: 0.2em 0.4em;
        border-radius: 3px;
      }

      /* Copy button styling */
      .copy-buttons {
        position: absolute;
        right: 0;
        top: 0;
        display: none;
        gap: 0.3em;
        background-color: var(--bg-color-light);
        padding: 0.3em;
        border-radius: 0.5em;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .assistant-message:hover .copy-buttons {
        display: flex;
        flex-direction: column;
      }

      .copy-button {
        padding: 0.3em 0.6em;
        font-size: 0.8em;
        opacity: 0.7;
      }

      .copy-button:hover {
        opacity: 1;
      }

      /* Settings menu styling */

      #settings-menu {
        position: absolute;
        bottom: calc(100% + 0.5em);
        right: 1em;
        background-color: var(--bg-color-light);
        border-radius: 1.11em;
        padding: 1em;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        display: none;
        flex-direction: column;
        gap: 0.5em;
        min-width: 200px;
      }

      #settings-menu.show {
        display: flex;
      }

      /* Modal styling */
      .modal {
        display: none;
        position: fixed;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
      }

      .modal.show {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .modal-content {
        background-color: var(--bg-color-light);
        padding: 2em;
        border-radius: 1.11em;
        width: 90%;
        max-width: 600px;
      }

      .modal textarea {
        width: 100%;
        height: 200px;
        margin: 1em 0;
        padding: 1em;
        border: none;
        border-radius: 1.11em;
        background-color: var(--wash-color-light);
        color: var(--text-color-light);
        font-family: monospace;
        font-size: 0.9em;
        resize: vertical;
      }

      .modal-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 0.5em;
      }

      /* Mobile Layout */
      @media (max-width: 600px) {
        form {
          flex-wrap: wrap;
        }

        #prompt-input {
          min-width: 100%;
          flex: 1 1 100%;
        }

        select {
          flex: 1;
          min-width: 0;
          max-width: none;
        }

        select,
        button {
          padding: 0.9em var(--border-radius);
        }
      }

      /* Dark Mode */
      @media (prefers-color-scheme: dark) {
        body {
          background-color: var(--bg-color-dark);
          color: var(--text-color-dark);
        }

        #prompt-input,
        select,
        button,
        pre,
        :not(pre) > code {
          background-color: var(--wash-color-dark);
          color: var(--text-color-dark);
        }

        pre {
          border-color: #444;
        }

        .think {
          color: #999999;
        }

        #input-container {
          background-color: rgba(26, 24, 24, 0.8);
        }

        .copy-buttons {
          background-color: var(--bg-color-dark);
        }

        #settings-menu {
          background-color: var(--bg-color-dark);
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .modal-content {
          background-color: var(--bg-color-dark);
        }
      }
    </style>
  </head>
  <body>
    <div id="chat-container"></div>
    <div id="input-container">
      <form id="prompt-form">
        <textarea
          id="prompt-input"
          rows="1"
          placeholder="Loading models..."
          autocomplete="off"
        ></textarea>
        <button type="submit">Send</button>
        <button type="button" id="settings-button">⚙️</button>
      </form>

      <!-- Settings menu -->
      <div id="settings-menu">
        <select id="model-selector" class="button-like">
          <option value="">Loading models...</option>
        </select>
        <button type="submit">Send</button>
        <button type="button" id="system-prompt-button">System Prompt</button>
      </div>
    </div>
    <!-- System Prompt Modal -->
    <div id="system-prompt-modal" class="modal">
      <div class="modal-content">
        <h2>Edit System Prompt</h2>
        <textarea id="system-prompt-textarea"></textarea>
        <div class="modal-buttons">
          <button type="button" id="cancel-system-prompt">Cancel</button>
          <button type="button" id="save-system-prompt">Save</button>
        </div>
      </div>
    </div>
  </body>
  <script>
    // Constants and configuration
    const CONFIG = {
      aiName: 'Oh',
      userName: 'Edouard',
      defaultModel: '',
      apiEndpoint: 'http://localhost:11434/api',
      nousApiEndpoint: '/nous',
      availableModels: [{ name: 'Hermes-3-Llama-3.1-70B', provider: 'nous' }],
      systemPrompt: `Your name is Oh.
    You will respond in a moderately friendly and straightforward manner.
    Your primary goal is to act as a helpful entity, providing information and answering questions to the best of your ability.
    You will do your best to never refuse a request for help.
    When explicitly asked, you should try and reveal the provenance of your knowledge or the mechanics with which you answered or came to a conclusion.
    When asked for code, preformatted text, or other intentionally-structured content, please wrap it in triple backticks (\`\`\`) for proper formatting.
    For inline code or short code snippets, use single backticks (\`).`,
    };

    // DOM elements cache
    const DOM = {
      form: document.getElementById('prompt-form'),
      input: document.getElementById('prompt-input'),
      chat: document.getElementById('chat-container'),
      modelSelector: document.getElementById('model-selector'),
    };

    // State management
    let currentModel = CONFIG.defaultModel;
    let currentProvider = 'ollama';
    let currentChatController = null;
    let conversationHistory = [
      {
        role: 'system',
        content: CONFIG.systemPrompt,
      },
    ];

    // Think div collapsing
    function handleThinkTransition(thinkDiv, shouldCollapse) {
      thinkDiv.classList.add('collapsing');

      if (shouldCollapse) {
        // Collapsing
        thinkDiv.style.maxHeight = thinkDiv.scrollHeight + 'px';
        // Force reflow
        thinkDiv.offsetHeight;
        requestAnimationFrame(() => {
          thinkDiv.style.maxHeight = '1.5em';
          thinkDiv.classList.add('collapsed');
          setTimeout(() => {
            thinkDiv.classList.remove('collapsing');
          }, 300);
        });
      } else {
        // Expanding
        thinkDiv.classList.remove('collapsed');
        const fullHeight = thinkDiv.scrollHeight;
        requestAnimationFrame(() => {
          thinkDiv.style.maxHeight = fullHeight + 'px';
          setTimeout(() => {
            thinkDiv.classList.remove('collapsing');
            thinkDiv.style.maxHeight = 'none';
          }, 300);
        });
      }
    }

    function collapseThinkDivs(container) {
      container.querySelectorAll('.think:not(.collapsed)').forEach(thinkDiv => {
        handleThinkTransition(thinkDiv, true);
      });
    }

    document.addEventListener('click', e => {
      if (e.target.classList.contains('think') || e.target.closest('.think')) {
        const thinkDiv = e.target.classList.contains('think')
          ? e.target
          : e.target.closest('.think');

        handleThinkTransition(
          thinkDiv,
          !thinkDiv.classList.contains('collapsed')
        );
      }
    });

    // Utility functions
    const escapeHtml = unsafe =>
      unsafe
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');

    const formatMessage = content => {
      if (!content) return '';
      return content
        .replace(/<think>([\s\S]*?)<\/think>/g, '<div class="think">$1</div>')
        .replace(/<think>([\s\S]*)$/, '<div class="think">$1</div>')
        .replace(
          /```(\w*)\n([\s\S]*?)```/g,
          (_, lang, code) =>
            `<pre><code class="language-${lang}">${escapeHtml(
              code.trim()
            )}</code></pre>`
        )
        .replace(
          /`([^`\n]+)`/g,
          (_, code) => `<code>${escapeHtml(code)}</code>`
        )
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    };

    // Scroll optimization with requestAnimationFrame
    const scrollToBottom = (() => {
      let rafId;
      let isStreaming = false;

      const scroll = () => {
        DOM.chat.scrollTop = DOM.chat.scrollHeight;
      };

      return (streaming = false) => {
        isStreaming = streaming;
        if (isStreaming) {
          scroll();
        } else {
          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(scroll);
        }
      };
    })();

    // Model management
    const updatePlaceholder = () => {
      DOM.input.placeholder = currentModel
        ? `Send a message to ${currentModel}`
        : 'Download ollama models to chat';
    };

    const fetchAvailableModels = async () => {
      try {
        // For Ollama models
        const response = await fetch(`${CONFIG.apiEndpoint}/tags`);
        if (!response.ok)
          throw new Error(`HTTP error! status: ${response.status}`);

        const { models } = await response.json();
        const ollamaModels = models.map(model => ({
          name: model.name,
          provider: 'ollama',
        }));

        // Combine Ollama models with Nous Research models (if any configured)
        const allModels = [
          ...ollamaModels,
          ...CONFIG.availableModels.filter(m => m.provider === 'nous'),
        ];

        if (allModels.length === 0) {
          // No models available
          DOM.modelSelector.innerHTML = `<option value="">Download ollama models to chat</option>`;
          currentModel = '';
          currentProvider = 'ollama';
          updatePlaceholder();
          return;
        }

        const modelOptions = allModels
          .map(
            model =>
              `<option value="${model.name}" data-provider="${model.provider}">${model.name} (${model.provider})</option>`
          )
          .join('');

        DOM.modelSelector.innerHTML = modelOptions;

        // Set initial model: prefer first Ollama model, otherwise first available
        const initialModel =
          ollamaModels.length > 0 ? ollamaModels[0] : allModels[0];
        currentModel = initialModel.name;
        currentProvider = initialModel.provider;
        DOM.modelSelector.value = currentModel;
        updatePlaceholder();
      } catch (error) {
        console.error('Error fetching models:', error);
        DOM.modelSelector.innerHTML = `<option value="">Download ollama models to chat</option>`;
        currentModel = '';
        updatePlaceholder();
      }
    };

    // Chat functionality
    const addMessageToChat = (role, content) => {
      const div = document.createElement('div');
      div.classList.add('message', `${role}-message`);

      if (role === 'assistant') {
        const contentDiv = document.createElement('div');
        contentDiv.classList.add('message-content');
        contentDiv.innerHTML = formatMessage(content);

        // Create container for copy buttons
        const copyButtons = document.createElement('div');
        copyButtons.classList.add('copy-buttons');

        // Add copy button for main content
        const mainCopyButton = document.createElement('button');
        mainCopyButton.classList.add('copy-button');
        mainCopyButton.textContent = 'Copy response';
        mainCopyButton.addEventListener('click', async () => {
          const textToCopy = Array.from(contentDiv.childNodes)
            .filter(node => !node.classList?.contains('think'))
            .map(node => node.textContent)
            .join('\n')
            .trim();
          await copyTextWithFeedback(textToCopy, mainCopyButton);
        });

        // Add copy button for think content
        const thinkCopyButton = document.createElement('button');
        thinkCopyButton.classList.add('copy-button');
        thinkCopyButton.textContent = 'Copy thought';
        thinkCopyButton.addEventListener('click', async () => {
          const thinkContent = Array.from(contentDiv.querySelectorAll('.think'))
            .map(node => node.textContent)
            .join('\n')
            .trim();
          await copyTextWithFeedback(thinkContent, thinkCopyButton);
        });

        copyButtons.appendChild(thinkCopyButton);
        copyButtons.appendChild(mainCopyButton);
        div.appendChild(copyButtons);
        div.appendChild(contentDiv);
      } else {
        div.innerHTML = formatMessage(content);
      }

      DOM.chat.appendChild(div);

      scrollToBottom();
      return div.querySelector('.message-content') || div;
    };

    // Helper function for copy functionality
    async function copyTextWithFeedback(text, button) {
      const originalText = button.textContent;
      try {
        await navigator.clipboard.writeText(text);
        button.textContent = 'Copied!';
      } catch (err) {
        console.error('Failed to copy:', err);
        button.textContent = 'Failed';
      }
      setTimeout(() => {
        button.textContent = originalText;
      }, 2000);
    }

    const handleSubmit = async e => {
      e.preventDefault();
      const prompt = DOM.input.value.trim();
      if (!prompt) return;

      if (currentChatController) {
        currentChatController.abort();
      }
      currentChatController = new AbortController();

      addMessageToChat('user', prompt);
      conversationHistory.push({ role: 'user', content: prompt });
      DOM.input.value = '';

      try {
        let response;
        if (currentProvider === 'nous') {
          // Nous Research API call - following OpenAI chat format
          response = await fetch(`${CONFIG.nousApiEndpoint}/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: currentModel,
              messages: conversationHistory,
              temperature: 0.7,
              max_tokens: 1000,
            }),
            signal: currentChatController.signal,
          });
        } else {
          // Ollama API call
          response = await fetch(`${CONFIG.apiEndpoint}/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: currentModel,
              messages: conversationHistory,
            }),
            signal: currentChatController.signal,
          });
        }

        if (!response.ok)
          throw new Error(`HTTP error! status: ${response.status}`);

        let assistantResponse = '';
        const assistantMessageElement = addMessageToChat('assistant', '');

        if (currentProvider === 'nous') {
          const data = await response.json();
          assistantResponse = data.choices[0].message.content;
          assistantMessageElement.innerHTML = formatMessage(assistantResponse);
          scrollToBottom(false);
        } else {
          const reader = response.body.getReader();
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunks = new TextDecoder().decode(value).split('\n');
            for (const chunk of chunks) {
              if (!chunk.trim()) continue;

              try {
                const { message } = JSON.parse(chunk);
                if (message?.content) {
                  assistantResponse += message.content;
                  assistantMessageElement.innerHTML =
                    formatMessage(assistantResponse);
                  scrollToBottom(true);
                }
              } catch (parseError) {
                console.warn('Failed to parse chunk:', parseError);
              }
            }
          }
          scrollToBottom(false);
        }

        conversationHistory.push({
          role: 'assistant',
          content: assistantResponse,
        });
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log('Request cancelled');
          return;
        }
        console.error('Error:', error);
        addMessageToChat(
          'error',
          `An error occurred: ${error.message}<br>Make sure the API service is running and accessible`
        );
      } finally {
        currentChatController = null;
        DOM.input.focus();
      }
    };

    // Settings menu functionality
    const settingsButton = document.getElementById('settings-button');
    const settingsMenu = document.getElementById('settings-menu');
    const systemPromptButton = document.getElementById('system-prompt-button');
    const systemPromptModal = document.getElementById('system-prompt-modal');
    const systemPromptTextarea = document.getElementById(
      'system-prompt-textarea'
    );
    const cancelSystemPromptButton = document.getElementById(
      'cancel-system-prompt'
    );
    const saveSystemPromptButton =
      document.getElementById('save-system-prompt');

    // Toggle settings menu
    settingsButton.addEventListener('click', e => {
      e.stopPropagation();
      settingsMenu.classList.toggle('show');
    });

    // Close settings menu when clicking outside
    document.addEventListener('click', e => {
      if (!settingsMenu.contains(e.target) && e.target !== settingsButton) {
        settingsMenu.classList.remove('show');
      }
    });

    // System prompt modal functionality
    systemPromptButton.addEventListener('click', () => {
      systemPromptTextarea.value = CONFIG.systemPrompt.trim();
      systemPromptModal.classList.add('show');
      settingsMenu.classList.remove('show');
    });

    cancelSystemPromptButton.addEventListener('click', () => {
      systemPromptModal.classList.remove('show');
    });

    saveSystemPromptButton.addEventListener('click', () => {
      CONFIG.systemPrompt = systemPromptTextarea.value;
      // Reset conversation history with new system prompt
      conversationHistory = [
        {
          role: 'system',
          content: CONFIG.systemPrompt,
        },
      ];
      systemPromptModal.classList.remove('show');
    });

    // Close modal when clicking outside
    systemPromptModal.addEventListener('click', e => {
      if (e.target === systemPromptModal) {
        systemPromptModal.classList.remove('show');
      }
    });

    // Move model selector to settings menu
    const modelSelector = document.getElementById('model-selector');
    settingsMenu.insertBefore(modelSelector, systemPromptButton);

    // Event Listeners
    DOM.form.addEventListener('submit', handleSubmit);
    DOM.input.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit(e);
      }
    });
    DOM.modelSelector.addEventListener('change', e => {
      const selectedOption = e.target.options[e.target.selectedIndex];
      currentModel = e.target.value;
      currentProvider = selectedOption.dataset.provider;
      updatePlaceholder();
    });

    // Auto-resize prompt textarea up to 5 lines
    const autoResize = () => {
      const el = DOM.input;
      // Reset height to compute scrollHeight correctly
      el.style.height = 'auto';
      const maxHeight = parseFloat(getComputedStyle(el).lineHeight) * 5;
      el.style.height = Math.min(el.scrollHeight, maxHeight) + 'px';
    };

    DOM.input.addEventListener('input', autoResize);
    // initialize
    autoResize();

    // Initialize
    window.addEventListener('load', () => {
      DOM.input.focus();
      fetchAvailableModels();
    });
  </script>
</html>
